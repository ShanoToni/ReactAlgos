{"version":3,"sources":["Components/splash.js","Components/list.js","Components/AlgoSpalash.js","App.js","SortAlgos/bubble.js","SortAlgos/selection.js","SortAlgos/quick.js","SearchAlgos/bfs.js","OtherAlgos/maze.js","SearchAlgos/dfs.js","SearchAlgos/astar.js","OtherAlgos/ray2d.js","OtherAlgos/quadtree.js","serviceWorker.js","index.js"],"names":["Splash","class","List","onAlgoChange","className","onClick","AlgoSplash","title","description","particlesOptions","particles","number","value","density","enable","value_area","line_linked","shadow","color","blur","algoData","name","algorithm","p","lastIdx","selected","values","swap","arr","idx1","idx2","a","async","sleep","temp","setup","createCanvas","i","Math","random","length","swapped","bubbleSort","draw","background","fill","rect","ms","Promise","resolve","setTimeout","firstUnsortedIdx","selectedItemIdx","comparingIdx","j","selectionSort","states","partition","start","end","pivotIndex","pivotValue","quickSort","index","all","w","h","cols","rows","grid","Array","Square","this","connectedSqures","blocked","visited","inQ","found","show","noStroke","ellipse","addConnections","push","createSplitIdx","passageIdx","splitIdx","floor","createMaze","startH","startV","endH","endV","horizontal","passage","queue","node","shift","BFS","stack","pop","f","g","previous","undefined","goal","heuristic","b","dist","removeFromArray","ele","splice","closedSet","openSet","lowestIdx","current","path","neighbours","neighbour","includes","tempG","aStar","particle","height","width","Boundary","x1","y1","x2","y2","createVector","stroke","line","x","y","Ray","pos","angle","dir","p5","Vector","fromAngle","translate","normalize","wall","x3","y3","x4","y4","den","t","pt","Particle","rays","heading","previousPos","radians","setAngle","walls","scene","ray","closest","record","Infinity","cast","d","cos","set","look","update","mouseX","mouseY","keyIsDown","rotate","sq","wSq","map","rectMode","CENTER","boundary","qt","Point","Rectangle","contains","point","intersects","range","Quadtree","cap","capacity","points","divided","insert","subdivide","topLeft","topRight","botLeft","botRight","tr","tl","br","bl","query","strokeWeight","noFill","randomGaussian","initState","algo","App","newAlgo","setState","forEach","idx","state","console","log","canvasClassName","params","sketch","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cc92e32b.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nfunction Splash() {\r\n    return(\r\n        <header class=\"sans-serif\">\r\n        <div class=\"cover bg-left bg-center-l\" >\r\n          <div class=\" pb5 pb6-m pb5-l\">\r\n            <nav class=\"dt w-100 mw8 center\"> \r\n              <div class=\"dtc v-mid tr pa3\">\r\n              </div>\r\n            </nav> \r\n              <div class=\"dtc w2 v-mid pa3\">\r\n                \r\n              </div>\r\n            <div class=\"tc-l mt4 mt5-m mt6-l ph3\">\r\n              <h1 class=\"f1 f1-l fw3 black mb0 lh-title\">Algorithm Visualization</h1>\r\n              <h2 class=\"fw1 f3 black mt3 mb2\">Showcasing algorithms by animating their work. Choose one and get started!</h2>\r\n              \r\n            </div>\r\n          </div>\r\n        </div> \r\n      </header>\r\n    );\r\n}\r\n\r\nexport default Splash;","import React from \"react\";\r\n\r\nfunction List({onAlgoChange}) {\r\n    return (\r\n        <div >\r\n            <div class=\"mw9 center ph3-ns\">\r\n                <div class=\"cf ph2-ns\">\r\n                    <div class=\"fl w-100 w-third-ns \">\r\n                        <h1 className=\"f4 bold center mw5\">Sorting</h1>\r\n                        <ul className=\"list pl0 ml0 center mw5 ba b--light-silver br3\">\r\n                            <li onClick={()=>onAlgoChange(\"bubble\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">BubbleSort</li>\r\n                            <li onClick={()=>onAlgoChange(\"selection\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">SelectionSort</li>\r\n                            <li onClick={()=>onAlgoChange(\"quick\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">QuickSort</li>\r\n                        </ul>\r\n                    </div>\r\n                    <div class=\"fl w-100 w-third-ns\">\r\n                        <h1 className=\"f4 bold center mw5\">Searching</h1>\r\n                        <ul className=\"list pl0 ml0 center mw5 ba b--light-silver br3\">\r\n                        <li onClick={()=>onAlgoChange(\"bfs\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">Breadth First Search</li>\r\n                        <li onClick={()=>onAlgoChange(\"dfs\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">Depth First Search</li>\r\n                        <li onClick={()=>onAlgoChange(\"astar\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">A* Search</li>\r\n                        </ul>\r\n                    </div>\r\n                    <div class=\"fl w-100 w-third-ns \">\r\n                        <h1 className=\"f4 bold center mw5\">Other</h1>\r\n                        <ul className=\"list pl0 ml0 center mw5 ba b--light-silver br3\">\r\n                        <li onClick={()=>onAlgoChange(\"maze\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">Maze Generation</li>\r\n                        <li onClick={()=>onAlgoChange(\"ray2d\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">2D Ray Casting</li>\r\n                        <li onClick={()=>onAlgoChange(\"quadtree\")} className=\"ph3 pv2 bb b--light-silver pointer hover-white \">Quad Tree</li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default List;","import React from \"react\";\r\n\r\nfunction AlgoSplash({onAlgoChange, title, description}) {\r\n    return(\r\n        <header className=\"sans-serif\">\r\n        <div className=\"cover bg-left bg-center-l\" >\r\n          <div className=\" pb5 pb6-m pb5-l\">\r\n            <nav className=\"dt w-100 mw8 center\"> \r\n              <div className=\"dtc v-mid tr pa3\">\r\n              </div>\r\n            </nav> \r\n              <div className=\"dtc w2 v-mid pa3\">\r\n                \r\n              </div>\r\n            <div className=\"tc-l mt4 mt5-m mt6-l ph3\">\r\n              <h1 className=\"f1 f1-l fw3 black mb0 lh-title\">{title}</h1>\r\n              <div className=\"flex justify-center marg\">\r\n                <h2 class=\"fw1 f3 black mt3 mb2 lh-copy\">{description}</h2>\r\n              </div>\r\n              <div className=\"flex justify-center\">\r\n                <ul className=\"list pl0 ml0 mw5 ba b--light-silver br3\">\r\n                  <li onClick={()=>onAlgoChange(\"none\")} className=\"ph4 pv3 bb b--light-silver pointer hover-white \">Home</li>\r\n                </ul>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div> \r\n      </header>\r\n    );\r\n}\r\n\r\nexport default AlgoSplash;","import React from 'react';\nimport Particles from 'react-particles-js';\nimport P5Wrapper from 'react-p5-wrapper';\n\nimport Splash from './Components/splash';\nimport List from './Components/list';\nimport AlgoSplash from \"./Components/AlgoSpalash\";\n\nimport './App.css';\n\nimport bubble from \"./SortAlgos/bubble\";\nimport selection from \"./SortAlgos/selection\";\nimport quick from \"./SortAlgos/quick\";\n\nimport bfs from \"./SearchAlgos/bfs\";\nimport dfs from \"./SearchAlgos/dfs\";\nimport astar from \"./SearchAlgos/astar\"\n\nimport maze from \"./OtherAlgos/maze\";\nimport ray2d from \"./OtherAlgos/ray2d\";\nimport quadtree from \"./OtherAlgos/quadtree\";\n\n\nconst particlesOptions = {\n  particles: {\n    number: {\n      value: 50,\n      density: {\n        enable: true,\n        value_area: 800\n      },\n      line_linked: {\n        shadow: {\n          enable: true,\n          color: \"#3CA9D1\",\n          blur: 5\n        }\n      }\n    }\n  },\n \n};\n\nconst algoData = [\n    {\n      name : \"bubble\",\n      title : \"Bubble Sort\",\n      description : \"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. It requires an O(n*n) time complexity on average while also requiring a large number of memory operations (swaps). Bubble sort is considered the simplest and most inefficient sorting algorithm\",\n      algorithm: bubble\n    },\n    {\n      name : \"selection\",\n      title : \"Selection Sort\",\n      description : \"The selection sort algorithm sorts an array by repeatedly finding the minimum element from unsorted part and putting it at the beginning. While having the same time complexity as Bubble Sort O(n*n) it is a superior algorithm due to the decrease of swaps occuring in the list.\",\n      algorithm :selection\n    },\n    {\n      name : \"quick\",\n      title : \"Quick Sort\",\n      description : \"QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. The key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements before it, and put all greater elements after it.\",\n      algorithm :quick\n    },\n    {\n      name : \"bfs\",\n      title : \"Breadth First Search\",\n      description : \"This algorithm is used to examine nodes looking for a correct answer or a goal node. The approach is based on a queue data structure. Upon visiting a new square all other squares are added to the back of the queue, while the next examined square is taken from the start of the queue. It is optimal for finding the shortest path, howerver high memory use.\",\n      algorithm :bfs\n    },\n    {\n      name : \"maze\",\n      title : \"Maze Generation \",\n      description : \"This algorithm is based on recursive division. It divides the scope of the field into two sections and chooses a random wall to create a passage. It continues to divide the filed until division is no longer possible creating a maze. Used in the search algorithms\",\n      algorithm :maze\n    },\n    {\n      name : \"dfs\",\n      title : \"Depth First Search \",\n      description : \"Similar to Breadth First it implements a data structure in order to do the traversal. The data structure used is a stack. Upon visiting a square all others are added to the stack, however the next examined square is taken from the back of the stack. While more efficient in memory use does not lead to optimal solutions.\",\n      algorithm :dfs\n    },\n    {\n      name : \"astar\",\n      title : \"A* Search \",\n      description : \"The A* algorithm is a more optimal traversal approach due to the use of a heuristic or an educated guess as to the goal node. The cost of travelling to each node is evaluated in comparison to how close it is to the node, allowing only potential optimal solutions to be examined.\",\n      algorithm : astar\n    },\n    {\n      name : \"ray2d\",\n      title : \"2D Ray Casting\",\n      description : \"Ray Casting is an approach to detect intersections between objects using by casting rays. Using a large amount of rays allows the ray intersection to draw rectangles to represent the distance to the object creating the illusion of 3D.\",\n      algorithm : ray2d\n    },\n    {\n      name : \"quadtree\",\n      title : \"Bounding Volume Heirarchy (Quadtree)\",\n      description : \"The Quadtree is also reffered to as a Kd-Tree is a case of spacial partitioning optimization, allowing large intersection tests to be done with consideration only towards the local objects.\",\n      algorithm : quadtree\n    },\n];\n  \n\n\nconst initState ={\n    algo: \"none\",\n    title: \"none\",\n    description: \"none\",\n    algorithm: null\n};\n\nclass App extends React.Component {\n  constructor(){\n    super();\n    this.state = (initState);\n  }\n\n  onAlgoChange = (newAlgo) =>{\n    this.setState({algo : newAlgo,}, ()=>{  \n      algoData.forEach((algo,idx,arr) =>{\n        if(this.state.algo === algo.name)\n        {\n          this.setState({\n            title:algo.title, \n            description: algo.description,\n            algorithm: algo.algorithm\n          });\n        }\n      })\n      console.log(this.state);\n    })\n  }\n\n  render(){\n    return (\n      <div className=\"App\">\n      <div className=\"backgroundParticles\">\n        <Particles  canvasClassName=\"particles\" params={particlesOptions} />\n      <div className=\"backgroundParticles\">\n        { this.state.algo === \"none\"\n         ? <div>\n            <Splash/>\n            <List onAlgoChange = {this.onAlgoChange}/>\n           </div>\n         : <div>\n            <AlgoSplash title={this.state.title} description={this.state.description} onAlgoChange = {this.onAlgoChange}/>\n            <div className=\"flex justify-center\">\n              <P5Wrapper sketch={this.state.algorithm} />\n            </div>\n          </div>\n        }\n          </div></div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export default function bubble (p) {\r\n    const height = 400;\r\n    const width = 600;\r\n    \r\n    let selected = [2];\r\n    let values = [60];\r\n    let lastIdx;\r\n    p.setup = function () {\r\n      p.createCanvas(width, height);\r\n      \r\n      for(let i = 0; i < 60; i++){\r\n          values[i] = Math.random()*height;\r\n      }\r\n      \r\n\r\n      //sorting magic\r\n      bubbleSort();\r\n    };\r\n    \r\n    async function bubbleSort(){\r\n        let swapped;\r\n        lastIdx = values.length-1;\r\n        do {\r\n            swapped = false;\r\n            for(let i=0; i< lastIdx;i++){\r\n                if(values[i]>values[i+1]){\r\n                   await swap(values, i, i+1);\r\n                    selected[0]=i;\r\n                    selected[1]=i+1;\r\n                    swapped = true;\r\n                }\r\n            }\r\n            lastIdx-=1;\r\n        }\r\n        while (swapped);\r\n    }\r\n    \r\n    \r\n    p.draw = function () {\r\n        p.background(100);\r\n        for(let i = 0; i< values.length; i++)\r\n        {\r\n            if(i>lastIdx){\r\n                p.fill(255,0,0);\r\n            } else {\r\n                p.fill(255);\r\n            }\r\n            \r\n            if (i === selected[0] || i === selected[1])\r\n            {\r\n                p.fill(0,255,0);\r\n            }\r\n            p.rect(i*10 , height, 10, -values[i] );\r\n        }\r\n    };\r\n    \r\n    async function swap (arr, idx1, idx2){\r\n        await sleep(25);\r\n         let temp = arr[idx1];\r\n         arr[idx1] = arr[idx2];\r\n         arr[idx2] = temp;\r\n     }\r\n\r\n    let sleep = (ms)=> {\r\n        return new Promise(resolve => setTimeout(resolve,ms));\r\n    }\r\n  };","export default function selection (p) {\r\n    const height = 400;\r\n    const width = 600;\r\n    \r\n    \r\n    let values = [60];\r\n    let firstUnsortedIdx;\r\n    let selectedItemIdx;\r\n    let comparingIdx;\r\n\r\n    p.setup = function () {\r\n      p.createCanvas(width, height);\r\n      \r\n      for(let i = 0; i < 60; i++){\r\n          values[i] = Math.random()*height;\r\n      }\r\n      \r\n\r\n      //sorting magic\r\n      selectionSort();\r\n    };\r\n    \r\n    async function selectionSort(){\r\n        for(let j = 0; j< values.length; j++){\r\n            firstUnsortedIdx = j;\r\n            selectedItemIdx = j;\r\n            for(let i = firstUnsortedIdx; i < values.length; i++)\r\n            {\r\n                comparingIdx = i;\r\n                if(values[selectedItemIdx] > values[i])\r\n                {\r\n                    selectedItemIdx = i;\r\n                }\r\n                await sleep(25);\r\n            }\r\n            await swap(values, selectedItemIdx, firstUnsortedIdx);\r\n        }\r\n       \r\n    }\r\n\r\n\r\n    p.draw = function () {\r\n        p.background(100);\r\n        for(let i = 0; i< values.length; i++)\r\n        {\r\n            if(i< firstUnsortedIdx){\r\n                p.fill(255,0,0);\r\n            } else {\r\n                p.fill(255);\r\n            }\r\n\r\n            if(i === selectedItemIdx) {\r\n                p.fill(255,165,0);\r\n            }\r\n            if(i === comparingIdx){\r\n                p.fill(0,255,0);\r\n            }\r\n            p.rect(i*10 , height, 10, -values[i] );\r\n        }\r\n    };\r\n\r\n   let swap = (arr, idx1, idx2) =>{\r\n        let temp = arr[idx1];\r\n        arr[idx1] = arr[idx2];\r\n        arr[idx2] = temp;\r\n    }\r\n\r\n    let sleep = (ms)=> {\r\n        return new Promise(resolve => setTimeout(resolve,ms));\r\n    }\r\n  };","export default function selection (p) {\r\n    const height = 400;\r\n    const width = 600;\r\n    \r\n    \r\n    let values = [60];\r\n    let states = [];\r\n    p.setup = function () {\r\n      p.createCanvas(width, height);\r\n      \r\n      for(let i = 0; i < 60; i++){\r\n          values[i] = Math.random()*height;\r\n          states[i] = -1;\r\n      }\r\n      \r\n\r\n      //sorting magic\r\n      quickSort(values,0, values.length-1);\r\n    };\r\n    \r\n    async function quickSort(arr, start, end){\r\n        if(start>=end){\r\n            return;\r\n        }\r\n        let index = await partition(arr,start,end);\r\n        states[index] = -1;\r\n        await Promise.all([quickSort(arr, start, index-1), quickSort(arr, index+1, end)]);\r\n        \r\n    }\r\n\r\n    async function partition(arr, start, end){\r\n\r\n        for(let i = start; i<=end; i++){\r\n            if(states[i] != 0)\r\n            {\r\n                states[i] = 1;\r\n            }\r\n        }\r\n\r\n        let pivotIndex = start;\r\n        let pivotValue = arr[end];\r\n        states[pivotIndex] = 0;\r\n        for(let i=start; i< end; i++){\r\n            if(arr[i]<pivotValue){\r\n                await swap(arr, i, pivotIndex);\r\n                states[pivotIndex] = -1;\r\n                pivotIndex++;\r\n                states[pivotIndex] = 0;\r\n            }\r\n        }\r\n        await swap(arr,pivotIndex, end);\r\n\r\n        for(let i = start; i<=end; i++){\r\n            if(states[i] != 0)\r\n            {\r\n                states[i] = -1;\r\n            }\r\n        }\r\n\r\n        return pivotIndex;\r\n    }\r\n\r\n\r\n    p.draw = function () {\r\n        p.background(100);\r\n        for(let i = 0; i< values.length; i++)\r\n        {\r\n            if(states[i] === 0){\r\n                p.fill(255,0,0);\r\n            } else if(states[i] === 1){\r\n                p.fill(0,0,255);\r\n            }else {\r\n                p.fill(255);\r\n            }\r\n            p.rect(i*10 , height, 10, -values[i] );\r\n        }\r\n    };\r\n\r\n   async function swap (arr, idx1, idx2){\r\n       await sleep(25);\r\n        let temp = arr[idx1];\r\n        arr[idx1] = arr[idx2];\r\n        arr[idx2] = temp;\r\n    }\r\n\r\n    let sleep = (ms)=> {\r\n        return new Promise(resolve => setTimeout(resolve,ms));\r\n    }\r\n  };","   export default function bfs (p) {\r\n        const height = 400;\r\n        const width = 600;\r\n        \r\n        let chance = 0.2;\r\n    \r\n        let cols = 20;\r\n        let rows = 20;\r\n        \r\n        let w,h;\r\n    \r\n        let grid = new Array(cols);\r\n    \r\n        p.setup = function () {\r\n          p.createCanvas(width, height);\r\n          \r\n            w = width / cols;\r\n            h = height / rows;\r\n    \r\n          for(let i = 0; i< cols; i++){\r\n              grid[i] = new Array(rows);\r\n          }\r\n    \r\n          for(let i = 0; i< cols; i++){\r\n              for(let j = 0; j < rows; j++){\r\n                grid[i][j] = new Square(i,j);\r\n            }\r\n        }\r\n        for(let i = 0; i< cols; i++){\r\n            for(let j = 0; j < rows; j++){\r\n                grid[i][j].addConnections();\r\n            }\r\n        }\r\n        createMaze( 0, 0, cols, rows, true,0);\r\n        BFS();\r\n    };      \r\n        function Square(i,j){\r\n            this.i = i\r\n            this.j = j;\r\n            this.connectedSqures = [];\r\n            this.blocked = false;\r\n            this.visited = false;\r\n            this.inQ = false;\r\n            this.found = false;\r\n    \r\n            this.show = ()=>{\r\n                if(this.blocked){\r\n                    p.fill(0);\r\n                }else if(this.found){\r\n                    p.fill(138,43,226);\r\n                } else if(this.inQ && !this.visited){\r\n                    p.fill(124,252,0);\r\n                } else if(this.visited){\r\n                    p.fill(255,99,71)\r\n                }else {\r\n                    p.fill(255);\r\n                }\r\n                p.noStroke();\r\n                p.ellipse(this.i*w+w/2, this.j*h+h/2,w/1.5,h/1.5)\r\n            }\r\n    \r\n            this.addConnections = ()=>{\r\n                if(this.i < cols-1){\r\n                    this.connectedSqures.push(grid[this.i+1][this.j]);\r\n                }\r\n                if(this.i > 0){\r\n                    this.connectedSqures.push(grid[this.i-1][this.j]);\r\n                }\r\n                if(this.j>0){\r\n                    this.connectedSqures.push(grid[this.i][this.j-1]);\r\n                }\r\n                if(this.j< rows-1){\r\n                    this.connectedSqures.push(grid[this.i][this.j+1]);\r\n                }\r\n                //diagonal\r\n                if(this.i < cols-1 && this.j< rows-1){\r\n                    this.connectedSqures.push(grid[this.i+1][this.j+1]);\r\n                }\r\n                if(this.i > 0 && this.j< rows-1){\r\n                    this.connectedSqures.push(grid[this.i-1][this.j+1]);\r\n                }\r\n                if(this.i < cols-1 && this.j > 0){\r\n                    this.connectedSqures.push(grid[this.i+1][this.j-1]);\r\n                }\r\n                if(this.i > 0 && this.j > 0){\r\n                    this.connectedSqures.push(grid[this.i-1][this.j-1]);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        async function BFS(){\r\n            let queue = [];\r\n    \r\n            queue.push(grid[0][0]);\r\n            grid[0][0].inQ = true;\r\n    \r\n            while(queue.length !== 0){\r\n                for(let i =0; i<queue.length; i++){\r\n                    let node = queue.shift();\r\n                    node.visited = true;\r\n                    if(node === grid[cols-1][rows-1]){\r\n                        node.found= true;;\r\n                        return;\r\n                    }\r\n                    for(let j = 0; j < node.connectedSqures.length; j++){\r\n                        if(node.connectedSqures[j]) {\r\n                            await sleep(50);\r\n                            if(!node.connectedSqures[j].visited && !node.connectedSqures[j].inQ && !node.connectedSqures[j].blocked){\r\n                                queue.push(node.connectedSqures[j]);\r\n                                node.connectedSqures[j].inQ = true;\r\n                            }\r\n                        }\r\n                    }\r\n    \r\n                }\r\n            }\r\n            return;\r\n        }\r\n    \r\n         function createMaze(startH, startV, endH, endV, horizontal, passageIdx) \r\n        {\r\n            if(horizontal && endV-startV >3){\r\n                let splitIdx = createSplitIdx(passageIdx, startV, endV);\r\n    \r\n                for(let i=startH; i< endH; i++){\r\n                    grid[i][splitIdx].blocked = true;\r\n                }\r\n                let passage = Math.floor(startH + ( Math.random() * (endH-startH-1)) );\r\n                grid[passage][splitIdx].blocked = false;\r\n                \r\n                \r\n                createMaze(startH, startV, endH, splitIdx, !horizontal,passage);\r\n                createMaze(startH, splitIdx, endH, endV, !horizontal,passage);\r\n                \r\n    \r\n            } else if(!horizontal && endH-startH > 3){\r\n                let splitIdx = createSplitIdx(passageIdx, startH, endH);\r\n                if(splitIdx === passageIdx)\r\n                {\r\n                    splitIdx++;\r\n                }\r\n                for(let i=startV; i< endV; i++){\r\n                    grid[splitIdx][i].blocked = true;\r\n                }\r\n                let passage = Math.floor(startV + ( Math.random() * (endV-startV-1)) );\r\n                grid[splitIdx][passage].blocked = false;\r\n                \r\n                createMaze(startH, startV, splitIdx, endV, !horizontal,passage);\r\n                createMaze(splitIdx, startV, endH, endV, !horizontal,passage);\r\n                \r\n            }\r\n        }\r\n    \r\n        function createSplitIdx(passageIdx, start, end){\r\n            let splitIdx = Math.floor((start + end) / 2);\r\n            if(splitIdx === passageIdx)\r\n            {\r\n                if(Math.random()>0.5){\r\n                    splitIdx++;\r\n                } else{\r\n                    splitIdx-=1;\r\n                }\r\n            }\r\n            return splitIdx;\r\n        }\r\n        p.draw = function () {\r\n            p.background(255);\r\n    \r\n            for(let i = 0; i< cols; i++){\r\n                for(let j = 0; j < rows; j++){\r\n                  grid[i][j].show();\r\n                }\r\n              }\r\n            \r\n        };\r\n    \r\n     \r\n    \r\n        let sleep = (ms)=> {\r\n            return new Promise(resolve => setTimeout(resolve,ms));\r\n        }\r\n      };","export default function bfs (p) {\r\n    const height = 400;\r\n    const width = 600;\r\n    \r\n    let chance = 0.2;\r\n\r\n    let cols = 20;\r\n    let rows = 20;\r\n    \r\n    let w,h;\r\n\r\n    let grid = new Array(cols);\r\n\r\n    p.setup = function () {\r\n      p.createCanvas(width, height);\r\n      \r\n        w = width / cols;\r\n        h = height / rows;\r\n\r\n      for(let i = 0; i< cols; i++){\r\n          grid[i] = new Array(rows);\r\n      }\r\n\r\n      for(let i = 0; i< cols; i++){\r\n          for(let j = 0; j < rows; j++){\r\n            grid[i][j] = new Square(i,j);\r\n        }\r\n    }\r\n    for(let i = 0; i< cols; i++){\r\n        for(let j = 0; j < rows; j++){\r\n            grid[i][j].addConnections();\r\n        }\r\n    }\r\n    \r\n    createMaze( 0, 0, cols, rows, true,0);\r\n};      \r\n    function Square(i,j){\r\n        this.i = i\r\n        this.j = j;\r\n        this.connectedSqures = [];\r\n        this.blocked = false;\r\n        this.visited = false;\r\n        this.inQ = false;\r\n        this.found = false;\r\n\r\n        this.show = ()=>{\r\n            if(this.blocked){\r\n                p.fill(0);\r\n            }else if(this.found){\r\n                p.fill(0,255,0);\r\n            } else if(this.inQ && !this.visited){\r\n                p.fill(0,0,255);\r\n            } else if(this.visited){\r\n                p.fill(255,0,0);\r\n            }else {\r\n                p.fill(255);\r\n            }\r\n            p.noStroke();\r\n            p.ellipse(this.i*w+w/2, this.j*h+h/2,w,h)\r\n        }\r\n\r\n        this.addConnections = ()=>{\r\n            if(this.i < cols-1){\r\n                this.connectedSqures.push(grid[this.i+1][this.j]);\r\n            }\r\n            if(this.i > 0){\r\n                this.connectedSqures.push(grid[this.i-1][this.j]);\r\n            }\r\n            if(this.j>0){\r\n                this.connectedSqures.push(grid[this.i][this.j-1]);\r\n            }\r\n            if(this.j< rows-1){\r\n                this.connectedSqures.push(grid[this.i][this.j+1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    async function createMaze(startH, startV, endH, endV, horizontal, passageIdx) \r\n    {\r\n        if(horizontal && endV-startV >3){\r\n            let splitIdx = createSplitIdx(passageIdx, startV, endV);\r\n\r\n            for(let i=startH; i< endH; i++){\r\n                grid[i][splitIdx].blocked = true;\r\n            }\r\n            let passage = Math.floor(startH + ( Math.random() * (endH-startH-1)) );\r\n            grid[passage][splitIdx].blocked = false;\r\n            await sleep(1000);\r\n            await Promise.all([\r\n                createMaze(startH, startV, endH, splitIdx, !horizontal,passage),\r\n                createMaze(startH, splitIdx, endH, endV, !horizontal,passage)\r\n            ]);\r\n\r\n        } else if(!horizontal && endH-startH > 3){\r\n            let splitIdx = createSplitIdx(passageIdx, startH, endH);\r\n            if(splitIdx === passageIdx)\r\n            {\r\n                splitIdx++;\r\n            }\r\n            for(let i=startV; i< endV; i++){\r\n                grid[splitIdx][i].blocked = true;\r\n            }\r\n            let passage = Math.floor(startV + ( Math.random() * (endV-startV-1)) );\r\n            grid[splitIdx][passage].blocked = false;\r\n            await sleep(1000);\r\n            await Promise.all([\r\n                createMaze(startH, startV, splitIdx, endV, !horizontal,passage),\r\n                createMaze(splitIdx, startV, endH, endV, !horizontal,passage)\r\n            ]);\r\n        }\r\n    }\r\n\r\n    function createSplitIdx(passageIdx, start, end){\r\n        let splitIdx = Math.floor((start + end) / 2);\r\n        if(splitIdx === passageIdx)\r\n        {\r\n            if(Math.random()>0.5){\r\n                splitIdx++;\r\n            } else{\r\n                splitIdx-=1;\r\n            }\r\n        }\r\n        return splitIdx;\r\n    }\r\n    p.draw = function () {\r\n        p.background(255);\r\n\r\n        for(let i = 0; i< cols; i++){\r\n            for(let j = 0; j < rows; j++){\r\n              grid[i][j].show();\r\n            }\r\n          }\r\n        \r\n    };\r\n\r\n \r\n\r\n    let sleep = (ms)=> {\r\n        return new Promise(resolve => setTimeout(resolve,ms));\r\n    }\r\n  };","export default function bfs (p) {\r\n    const height = 400;\r\n    const width = 600;\r\n    \r\n    let chance = 0.2;\r\n\r\n    let cols = 20;\r\n    let rows = 20;\r\n    \r\n    let w,h;\r\n\r\n    let grid = new Array(cols);\r\n\r\n    p.setup = function () {\r\n      p.createCanvas(width, height);\r\n      \r\n        w = width / cols;\r\n        h = height / rows;\r\n\r\n      for(let i = 0; i< cols; i++){\r\n          grid[i] = new Array(rows);\r\n      }\r\n\r\n      for(let i = 0; i< cols; i++){\r\n          for(let j = 0; j < rows; j++){\r\n            grid[i][j] = new Square(i,j);\r\n        }\r\n    }\r\n    for(let i = 0; i< cols; i++){\r\n        for(let j = 0; j < rows; j++){\r\n            grid[i][j].addConnections();\r\n        }\r\n    }\r\n    createMaze( 0, 0, cols, rows, true,0);\r\n    BFS();\r\n};      \r\n    function Square(i,j){\r\n        this.i = i\r\n        this.j = j;\r\n        this.connectedSqures = [];\r\n        this.blocked = false;\r\n        this.visited = false;\r\n        this.inQ = false;\r\n        this.found = false;\r\n\r\n        this.show = ()=>{\r\n            if(this.blocked){\r\n                p.fill(0);\r\n            }else if(this.found){\r\n                p.fill(138,43,226);                ;\r\n            } else if(this.inQ && !this.visited){\r\n                p.fill(124,252,0);\r\n            } else if(this.visited){\r\n                p.fill(255,99,71)\r\n            }else {\r\n                p.fill(255);\r\n            }\r\n            p.noStroke();\r\n            p.ellipse(this.i*w+w/2, this.j*h+h/2,w/1.5,h/1.5)\r\n        }\r\n\r\n        this.addConnections = ()=>{\r\n            if(this.i < cols-1){\r\n                this.connectedSqures.push(grid[this.i+1][this.j]);\r\n            }\r\n            if(this.i > 0){\r\n                this.connectedSqures.push(grid[this.i-1][this.j]);\r\n            }\r\n            if(this.j>0){\r\n                this.connectedSqures.push(grid[this.i][this.j-1]);\r\n            }\r\n            if(this.j< rows-1){\r\n                this.connectedSqures.push(grid[this.i][this.j+1]);\r\n            }\r\n            //diagonal\r\n            if(this.i < cols-1 && this.j< rows-1){\r\n                this.connectedSqures.push(grid[this.i+1][this.j+1]);\r\n            }\r\n            if(this.i > 0 && this.j< rows-1){\r\n                this.connectedSqures.push(grid[this.i-1][this.j+1]);\r\n            }\r\n            if(this.i < cols-1 && this.j > 0){\r\n                this.connectedSqures.push(grid[this.i+1][this.j-1]);\r\n            }\r\n            if(this.i > 0 && this.j > 0){\r\n                this.connectedSqures.push(grid[this.i-1][this.j-1]);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    async function BFS(){\r\n        let stack = [];\r\n\r\n        stack.push(grid[0][0]);\r\n        grid[0][0].inQ = true;\r\n\r\n        while(stack.length !== 0){\r\n            for(let i =0; i<stack.length; i++){\r\n                let node = stack.pop();\r\n                node.visited = true;\r\n                if(node === grid[cols-1][rows-1]){\r\n                    node.found= true;;\r\n                    return;\r\n                }\r\n                for(let j = 0; j < node.connectedSqures.length; j++){\r\n                    if(node.connectedSqures[j]) {\r\n                        await sleep(50);\r\n                        if(!node.connectedSqures[j].visited && !node.connectedSqures[j].inQ && !node.connectedSqures[j].blocked){\r\n                            stack.push(node.connectedSqures[j]);\r\n                            node.connectedSqures[j].inQ = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n     function createMaze(startH, startV, endH, endV, horizontal, passageIdx) \r\n    {\r\n        if(horizontal && endV-startV >3){\r\n            let splitIdx = createSplitIdx(passageIdx, startV, endV);\r\n\r\n            for(let i=startH; i< endH; i++){\r\n                grid[i][splitIdx].blocked = true;\r\n            }\r\n            let passage = Math.floor(startH + ( Math.random() * (endH-startH-1)) );\r\n            grid[passage][splitIdx].blocked = false;\r\n            \r\n            \r\n            createMaze(startH, startV, endH, splitIdx, !horizontal,passage);\r\n            createMaze(startH, splitIdx, endH, endV, !horizontal,passage);\r\n            \r\n\r\n        } else if(!horizontal && endH-startH > 3){\r\n            let splitIdx = createSplitIdx(passageIdx, startH, endH);\r\n            if(splitIdx === passageIdx)\r\n            {\r\n                splitIdx++;\r\n            }\r\n            for(let i=startV; i< endV; i++){\r\n                grid[splitIdx][i].blocked = true;\r\n            }\r\n            let passage = Math.floor(startV + ( Math.random() * (endV-startV-1)) );\r\n            grid[splitIdx][passage].blocked = false;\r\n            \r\n            createMaze(startH, startV, splitIdx, endV, !horizontal,passage);\r\n            createMaze(splitIdx, startV, endH, endV, !horizontal,passage);\r\n            \r\n        }\r\n    }\r\n\r\n    function createSplitIdx(passageIdx, start, end){\r\n        let splitIdx = Math.floor((start + end) / 2);\r\n        if(splitIdx === passageIdx)\r\n        {\r\n            if(Math.random()>0.5){\r\n                splitIdx++;\r\n            } else{\r\n                splitIdx-=1;\r\n            }\r\n        }\r\n        return splitIdx;\r\n    }\r\n    p.draw = function () {\r\n        p.background(255);\r\n\r\n        for(let i = 0; i< cols; i++){\r\n            for(let j = 0; j < rows; j++){\r\n              grid[i][j].show();\r\n            }\r\n          }\r\n        \r\n    };\r\n\r\n \r\n\r\n    let sleep = (ms)=> {\r\n        return new Promise(resolve => setTimeout(resolve,ms));\r\n    }\r\n  };","export default function bfs(p) {\r\n    const height = 400;\r\n    const width = 600;\r\n\r\n    let cols = 30;\r\n    let rows = 30;\r\n\r\n    let w, h;\r\n\r\n    let grid = new Array(cols);\r\n\r\n    p.setup = function () {\r\n        p.createCanvas(width, height);\r\n\r\n        w = width / cols;\r\n        h = height / rows;\r\n\r\n        for (let i = 0; i < cols; i++) {\r\n            grid[i] = new Array(rows);\r\n        }\r\n\r\n        for (let i = 0; i < cols; i++) {\r\n            for (let j = 0; j < rows; j++) {\r\n                grid[i][j] = new Square(i, j);\r\n            }\r\n        }\r\n        for (let i = 0; i < cols; i++) {\r\n            for (let j = 0; j < rows; j++) {\r\n                grid[i][j].addConnections();\r\n            }\r\n        }\r\n\r\n        grid[cols - 1][rows - 1].goal = true;\r\n\r\n        createMaze( 0, 0, cols, rows, true,0);\r\n        aStar();\r\n    };\r\n    function Square(i, j) {\r\n        this.f = 0;\r\n        this.h = 0;\r\n        this.g = 0;\r\n\r\n        this.i = i\r\n        this.j = j;\r\n        this.connectedSqures = [];\r\n        this.previous = undefined;\r\n\r\n        this.blocked = false;\r\n        this.visited = false;\r\n        this.inQ = false;\r\n        this.found = false;\r\n        this.goal = false;\r\n\r\n        this.show = () => {\r\n            if (this.blocked) {\r\n                p.fill(0);\r\n            } else if (this.goal) {\r\n                p.fill(30,144,255);\r\n            } else if (this.found) {\r\n                p.fill(138, 43, 226);\r\n            } else if (this.inQ && !this.visited) {\r\n                p.fill(124, 252, 0);\r\n            } else if (this.visited) {\r\n                p.fill(255, 99, 71)\r\n            } else {\r\n                p.fill(255);\r\n            }\r\n            p.noStroke();\r\n            p.ellipse(this.i * w + w / 2, this.j * h + h / 2, w / 1.5, h / 1.5)\r\n        }\r\n\r\n        this.addConnections = () => {\r\n            if (this.i < cols - 1) {\r\n                this.connectedSqures.push(grid[this.i + 1][this.j]);\r\n            }\r\n            if (this.i > 0) {\r\n                this.connectedSqures.push(grid[this.i - 1][this.j]);\r\n            }\r\n            if (this.j > 0) {\r\n                this.connectedSqures.push(grid[this.i][this.j - 1]);\r\n            }\r\n            if (this.j < rows - 1) {\r\n                this.connectedSqures.push(grid[this.i][this.j + 1]);\r\n            }\r\n            //diagonal\r\n            if (this.i < cols - 1 && this.j < rows - 1) {\r\n                this.connectedSqures.push(grid[this.i + 1][this.j + 1]);\r\n            }\r\n            if (this.i > 0 && this.j < rows - 1) {\r\n                this.connectedSqures.push(grid[this.i - 1][this.j + 1]);\r\n            }\r\n            if (this.i < cols - 1 && this.j > 0) {\r\n                this.connectedSqures.push(grid[this.i + 1][this.j - 1]);\r\n            }\r\n            if (this.i > 0 && this.j > 0) {\r\n                this.connectedSqures.push(grid[this.i - 1][this.j - 1]);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    async function aStar() {\r\n        let openSet = [];\r\n        let closedSet = [];\r\n\r\n        openSet.push(grid[0][0]);\r\n        grid[0][0].inQ = true;\r\n\r\n        while (openSet.length > 0) {\r\n            let lowestIdx = 0;\r\n            for (let i = 0; i < openSet.length; i++) {\r\n                if (openSet[i].f < openSet[lowestIdx].f) {\r\n                    lowestIdx = i;\r\n                }\r\n            }\r\n            await sleep (10);\r\n            let current = openSet[lowestIdx];\r\n\r\n            if (openSet[lowestIdx].goal) {\r\n\r\n                let path = [];\r\n                let temp = current;\r\n                path.push(temp);\r\n                while(temp.previous)\r\n                {\r\n                    path.push(temp.previous);\r\n                    temp = temp.previous;\r\n                    temp.goal = true;\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            closedSet.push(current);\r\n            current.visited = true;\r\n            removeFromArray(openSet, current);\r\n\r\n            let neighbours = current.connectedSqures;\r\n\r\n            for (let i = 0; i < neighbours.length; i++) {\r\n                if(!neighbours[i].blocked)\r\n                {    \r\n                    let neighbour = neighbours[i];\r\n                    \r\n                    if (!closedSet.includes(neighbour)) {\r\n                        let tempG = current.g + 1;\r\n                        \r\n                        if (openSet.includes(neighbour)) {\r\n                            if (tempG < neighbour.g) {\r\n                                neighbour.g = tempG;\r\n                            }\r\n                        } else {\r\n                            neighbour.g = tempG;\r\n                            openSet.push(neighbour);\r\n                            neighbour.inQ = true;\r\n                            neighbour.previous = current;\r\n                        }\r\n                    } \r\n    \r\n                    neighbour.h = heuristic(neighbour, grid[cols-1][rows-1]);\r\n                    neighbour.f = neighbour.g + neighbour.h;\r\n                }\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    function heuristic(a, b) {\r\n        let d = p.dist(a.i, a.j, b.i, b.j);\r\n        return d;\r\n    }\r\n\r\n    function removeFromArray(arr, ele) {\r\n        for (let i = arr.length - 1; i >= 0; i--) {\r\n            if (arr[i] == ele) {\r\n                arr.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function createMaze(startH, startV, endH, endV, horizontal, passageIdx) {\r\n        if (horizontal && endV - startV > 3) {\r\n            let splitIdx = createSplitIdx(passageIdx, startV, endV);\r\n\r\n            for (let i = startH; i < endH; i++) {\r\n                grid[i][splitIdx].blocked = true;\r\n            }\r\n            let passage = Math.floor(startH + (Math.random() * (endH - startH - 1)));\r\n            grid[passage][splitIdx].blocked = false;\r\n\r\n\r\n            createMaze(startH, startV, endH, splitIdx, !horizontal, passage);\r\n            createMaze(startH, splitIdx, endH, endV, !horizontal, passage);\r\n\r\n\r\n        } else if (!horizontal && endH - startH > 3) {\r\n            let splitIdx = createSplitIdx(passageIdx, startH, endH);\r\n            if (splitIdx === passageIdx) {\r\n                splitIdx++;\r\n            }\r\n            for (let i = startV; i < endV; i++) {\r\n                grid[splitIdx][i].blocked = true;\r\n            }\r\n            let passage = Math.floor(startV + (Math.random() * (endV - startV - 1)));\r\n            grid[splitIdx][passage].blocked = false;\r\n\r\n            createMaze(startH, startV, splitIdx, endV, !horizontal, passage);\r\n            createMaze(splitIdx, startV, endH, endV, !horizontal, passage);\r\n\r\n        }\r\n    }\r\n    function createSplitIdx(passageIdx, start, end){\r\n        let splitIdx = Math.floor((start + end) / 2);\r\n        if(splitIdx === passageIdx)\r\n        {\r\n            if(Math.random()>0.5){\r\n                splitIdx++;\r\n            } else{\r\n                splitIdx-=1;\r\n            }\r\n        }\r\n        return splitIdx;\r\n    }\r\n    p.draw = function () {\r\n        p.background(255);\r\n\r\n        for(let i = 0; i< cols; i++){\r\n            for(let j = 0; j < rows; j++){\r\n              grid[i][j].show();\r\n            }\r\n          }\r\n        \r\n    };\r\n\r\n\r\n    let sleep = (ms) => {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n};","import p5 from \"p5\"\r\n\r\nexport default function ray2d(p) {\r\n    const height = 400;\r\n    const width = 400;\r\n\r\n    class Boundary {\r\n        constructor(x1, y1, x2, y2) {\r\n            this.a = p.createVector(x1, y1);\r\n            this.b = p.createVector(x2, y2);\r\n        }\r\n\r\n        show() {\r\n            p.stroke(255);\r\n            p.line(this.a.x, this.a.y, this.b.x, this.b.y);\r\n        }\r\n    }\r\n\r\n    class Ray {\r\n        constructor(pos, angle) {\r\n            this.pos = pos;\r\n            this.dir = p5.Vector.fromAngle(angle);\r\n        }\r\n\r\n        show() {\r\n            p.stroke(255);\r\n            p.push();\r\n            p.translate(this.pos.x, this.pos.y);\r\n            p.line(0, 0, this.dir.x * 10, this.dir.y * 10);\r\n            p.pop()\r\n        }\r\n\r\n        setAngle(angle) {\r\n            this.dir = p5.Vector.fromAngle(angle);\r\n        }\r\n\r\n        lookAt(x, y) {\r\n            this.dir.x = x - this.pos.x;\r\n            this.dir.y = y - this.pos.y;\r\n            this.dir.normalize();\r\n        }\r\n\r\n        cast(wall) {\r\n            const x1 = wall.a.x;\r\n            const y1 = wall.a.y;\r\n            const x2 = wall.b.x;\r\n            const y2 = wall.b.y;\r\n\r\n            const x3 = this.pos.x;\r\n            const y3 = this.pos.y;\r\n            const x4 = this.pos.x + this.dir.x;\r\n            const y4 = this.pos.y + this.dir.y;\r\n\r\n            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n            if (den === 0) {\r\n                return;\r\n            }\r\n\r\n            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\r\n            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\r\n\r\n            if (t > 0 && t < 1 && u > 0) {\r\n                const pt = p.createVector();\r\n                pt.x = x1 + t * (x2 - x1);\r\n                pt.y = y1 + t * (y2 - y1);\r\n                return pt;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    class Particle {\r\n        constructor() {\r\n            this.pos = p.createVector(width / 2, height / 2);\r\n            this.rays = [];\r\n            this.heading = 0;\r\n            this.previousPos = p.createVector(width / 2, height / 2);\r\n            for (let i = -40; i < 40; i++) {\r\n                this.rays.push(new Ray(this.pos, p.radians(i)));\r\n            }\r\n        }\r\n\r\n        rotate(angle) {\r\n            this.heading += angle;\r\n            for (let i = 0; i < this.rays.length; i++) {\r\n                this.rays[i].setAngle(p.radians(i) + this.heading);\r\n            }\r\n        }\r\n\r\n        show() {\r\n            p.fill(255);\r\n            p.ellipse(this.pos.x, this.pos.y, 4);\r\n            for (let i = 0; i < this.rays.length; i++) {\r\n                this.rays[i].show();\r\n            }\r\n        }\r\n\r\n        look(walls) {\r\n            const scene = [];\r\n            for (let i = 0; i < this.rays.length; i++) {\r\n                const ray = this.rays[i];\r\n                let closest = null;\r\n                let record = Infinity;\r\n\r\n                for (let wall of walls) {\r\n                    const pt = ray.cast(wall);\r\n                    if (pt) {\r\n                        let d = p5.Vector.dist(this.pos, pt);\r\n                        const a = ray.dir.heading() - this.heading;\r\n                        d = d * p.cos(a);\r\n                        if (d < record) {\r\n                            record = d;\r\n                            closest = pt;\r\n                        }\r\n                    }\r\n                }\r\n                if (closest) {\r\n                    p.stroke(255, 100);\r\n                    p.line(this.pos.x, this.pos.y, closest.x, closest.y);\r\n                }\r\n                scene[i] = record;\r\n            }\r\n            return scene;\r\n        }\r\n\r\n        update(x, y) {\r\n            this.pos.set(x, y);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    let walls = [];\r\n    let particle;\r\n    let scene = [];\r\n\r\n    let keyPress = () =>{\r\n        if(p.keyIsDown(81)){\r\n            particle.rotate(-0.05);\r\n        }\r\n        if(p.keyIsDown(69)){\r\n            particle.rotate(0.05);\r\n        }\r\n\r\n    }\r\n\r\n    p.setup = function () {\r\n        p.createCanvas(width * 2, height);\r\n        walls.push(new Boundary(0, 0, width, 0));\r\n        walls.push(new Boundary(0, height, width, height));\r\n        walls.push(new Boundary(0, 0, 0, height));\r\n        walls.push(new Boundary(width, 0, width, height));\r\n        for (let i = 0; i < 5; i++) {\r\n            let x1 = p.random(width);\r\n            let y1 = p.random(height);\r\n            let x2 = p.random(width);\r\n            let y2 = p.random(height);\r\n            walls.push(new Boundary(x1, y1, x2, y2));\r\n        }\r\n\r\n\r\n        particle = new Particle();\r\n    };\r\n\r\n\r\n  \r\n\r\n    p.draw = function () {\r\n        p.background(0);\r\n        for (let wall of walls) {\r\n            wall.show();\r\n        }\r\n        scene = particle.look(walls);\r\n        particle.show();\r\n        particle.update(p.mouseX, p.mouseY);\r\n        \r\n        keyPress();\r\n\r\n        const w = width / scene.length;\r\n        p.push();\r\n        p.translate(width, 0);\r\n        for (let i = 0; i < scene.length; i++) {\r\n            const sq = scene[i] * scene[i];\r\n            const wSq = width * width;\r\n            const b = p.map(sq, 0, wSq, 255, 0);\r\n            const h = p.map(sq, 0, wSq, height, 0);\r\n            p.noStroke();\r\n            p.fill(b);\r\n            p.rectMode(p.CENTER);\r\n            p.rect(i * w + w / 2, height / 2, w, h);\r\n        }\r\n        p.pop();\r\n    };\r\n\r\n\r\n\r\n};","import p5 from \"p5\"\r\n\r\nexport default function quadtree(p) {\r\n    const height = 400;\r\n    const width = 600;\r\n\r\n    function Point(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    function Rectangle(x, y, w, h) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n\r\n        this.contains = (point) => {\r\n            return (point.x >= this.x - this.w &&\r\n                point.x <= this.x + this.w &&\r\n                point.y >= this.y - this.h &&\r\n                point.y <= this.y + this.h);\r\n        }\r\n\r\n        this.intersects = (range) => {\r\n            return !(range.x - range.w > this.x + this.w ||\r\n                range.x + range.w < this.x - this.w ||\r\n                range.y - range.h > this.y + this.h ||\r\n                range.y + range.h < this.y - this.w)\r\n        }\r\n    }\r\n\r\n    function Quadtree(boundary, cap) {\r\n        this.boundary = boundary;\r\n        this.capacity = cap;\r\n        this.points = [];\r\n        this.divided = false;\r\n\r\n        this.insert = (point) => {\r\n\r\n            if (!this.boundary.contains(point)) {\r\n                return false;\r\n            }\r\n\r\n            if (this.points.length < this.capacity) {\r\n                this.points.push(point);\r\n                return true;\r\n            } else {\r\n                if (!this.divided) {\r\n                    this.subdivide();\r\n                }\r\n                if (this.topLeft.insert(point)) {\r\n                    return true;\r\n                } else if (this.topRight.insert(point)) {\r\n                    return true;\r\n                } else if (this.botLeft.insert(point)) {\r\n                    return true;\r\n                } else if (this.botRight.insert(point)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.subdivide = () => {\r\n            let x = this.boundary.x;\r\n            let y = this.boundary.y;\r\n            let w = this.boundary.w;\r\n            let h = this.boundary.h;\r\n\r\n            let tr = new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2);\r\n            this.topRight = new Quadtree(tr, this.capacity);\r\n\r\n            let tl = new Rectangle(x + w / 2, y - h / 2, w / 2, h / 2);\r\n            this.topLeft = new Quadtree(tl, this.capacity);\r\n\r\n            let br = new Rectangle(x - w / 2, y + h / 2, w / 2, h / 2);\r\n            this.botRight = new Quadtree(br, this.capacity);\r\n\r\n            let bl = new Rectangle(x - w / 2, y - h / 2, w / 2, h / 2);\r\n            this.botLeft = new Quadtree(bl, this.capacity);\r\n\r\n            this.divided = true;\r\n        }\r\n\r\n        this.query = (range, found) => {\r\n            if (!this.boundary.intersects(range)) {\r\n                return;\r\n            } else {\r\n                for (let point of this.points) {\r\n                    if (range.contains(point)) {\r\n                        found.push(point);\r\n                    }\r\n                }\r\n\r\n                if (this.divided) {\r\n                    this.topLeft.query(range, found);\r\n                    this.topRight.query(range, found);\r\n                    this.botLeft.query(range, found);\r\n                    this.botRight.query(range, found);\r\n                }\r\n                return found;\r\n            }\r\n        }\r\n\r\n        this.show = () => {\r\n            p.stroke(255);\r\n            p.strokeWeight(1);\r\n            p.rectMode(p.CENTER);\r\n            p.noFill();\r\n            p.rect(this.boundary.x, this.boundary.y, this.boundary.w * 2, this.boundary.h * 2);\r\n            if (this.divided) {\r\n                this.topLeft.show();\r\n                this.topRight.show();\r\n                this.botLeft.show();\r\n                this.botRight.show();\r\n            }\r\n            for (let point of this.points) {\r\n                p.strokeWeight(2);\r\n                p.point(point.x, point.y);\r\n            }\r\n        }\r\n    }\r\n\r\n    let boundary;\r\n    let qt;\r\n\r\n    p.setup = function () {\r\n        p.createCanvas(width, height);\r\n\r\n        boundary = new Rectangle(width / 2, height / 2, width / 2, height / 2);\r\n        qt = new Quadtree(boundary, 4);\r\n        for (let i = 0; i < 300; i++) {\r\n            let x = p.randomGaussian(width/2, width/6);\r\n            let y = p.randomGaussian(height/2, height/6);\r\n            let point = new Point(x,y);\r\n            qt.insert(point);\r\n        }\r\n\r\n    };\r\n\r\n\r\n\r\n\r\n    p.draw = function () {\r\n        p.background(0);\r\n\r\n        p.stroke(0, 255, 0);\r\n        p.rectMode(p.CENTER);\r\n\r\n        let range = new Rectangle(p.mouseX, p.mouseY, 107, 74);\r\n        p.rect(range.x, range.y, range.w * 2, range.h * 2);\r\n        let points = new Array();\r\n        qt.query(range, points);\r\n        for (let point of points) {\r\n            p.strokeWeight(8);\r\n            p.point(point.x, point.y);\r\n        }\r\n\r\n        qt.show();\r\n    };\r\n\r\n\r\n\r\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport \"tachyons\";\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}